# Autogenerated param section. Do not hand edit.
param {
group.0 {
name=Dynamically Reconfigurable Parameters
desc=See the [[dynamic_reconfigure]] package for details on dynamically reconfigurable parameters.
0.name= ~teb_autosize
0.default= True
0.type= bool
0.desc=Enable the automatic resizing of the trajectory during optimization (based on the temporal resolution of the trajectory, recommended) 
1.name= ~dt_ref
1.default= 0.3
1.type= double
1.desc=Temporal resolution of the planned trajectory (usually it is set to the magnitude of the 1/control_rate) Range: 0.01 to 1.0
2.name= ~dt_hysteresis
2.default= 0.1
2.type= double
2.desc=Hysteresis that is utilized for automatic resizing depending on the current temporal resolution (dt): usually 10% of dt_ref Range: 0.002 to 0.5
3.name= ~global_plan_overwrite_orientation
3.default= True
3.type= bool
3.desc=Some global planners are not considering the orientation at local subgoals between start and global goal, therefore determine it automatically 
4.name= ~allow_init_with_backwards_motion
4.default= False
4.type= bool
4.desc=If true, the underlying trajectories might be initialized with backwards motions in case the goal is behind the start within the local costmap (this is only recommended if the robot is equipped with rear sensors) 
5.name= ~max_global_plan_lookahead_dist
5.default= 3.0
5.type= double
5.desc=Specify maximum length (cumulative Euclidean distances) of the subset of the global plan taken into account for optimization [if 0 or negative: disabled; the length is also bounded by the local costmap size] Range: 0.0 to 50.0
6.name= ~force_reinit_new_goal_dist
6.default= 1.0
6.type= double
6.desc=Force the planner to reinitialize the trajectory if a previous goal is updated with a seperation of more than the specified value in meters (skip hot-starting) Range: 0.0 to 10.0
7.name= ~force_reinit_new_goal_angular
7.default= 0.78
7.type= double
7.desc=Force the planner to reinitialize the trajectory if a previous goal is updated with a rotational difference of more than the specified value in radians (skip hot-starting) Range: 0.0 to 4.0
8.name= ~feasibility_check_no_poses
8.default= 5
8.type= int
8.desc=Specify up to which pose (under the feasibility_check_lookahead_distance) on the predicted plan the feasibility should be checked each sampling interval; if -1, all poses up to feasibility_check_lookahead_distance are checked. Range: -1 to 50
9.name= ~feasibility_check_lookahead_distance
9.default= -1.0
9.type= double
9.desc=Specify up to which distance (and with an index below feasibility_check_no_poses) from the robot the feasibility should be checked each sampling interval; if -1, all poses up to feasibility_check_no_poses are checked. Range: -1.0 to 20.0
10.name= ~exact_arc_length
10.default= False
10.type= bool
10.desc=If true, the planner uses the exact arc length in velocity, acceleration and turning rate computations [-> increased cpu time], otherwise the euclidean approximation is used. 
11.name= ~publish_feedback
11.default= False
11.type= bool
11.desc=Publish planner feedback containing the full trajectory and a list of active obstacles (should be enabled only for evaluation or debugging purposes) 
12.name= ~control_look_ahead_poses
12.default= 1
12.type= int
12.desc=Index of the pose used to extract the velocity command Range: 1 to 100
13.name= ~prevent_look_ahead_poses_near_goal
13.default= 0
13.type= int
13.desc=Prevents control_look_ahead_poses to look within this many poses of the goal in order to prevent overshoot & oscillation when xy_goal_tolerance is very small Range: 0 to 20
14.name= ~visualize_with_time_as_z_axis_scale
14.default= 0.0
14.type= double
14.desc=If this value is bigger than 0, the trajectory and obstacles are visualized in 3d using the time as the z-axis scaled by this value. Most useful for dynamic obstacles. Range: 0.0 to 1.0
15.name= ~global_plan_viapoint_sep
15.default= -0.1
15.type= double
15.desc=Min. separation between each two consecutive via-points extracted from the global plan [if negative: disabled] Range: -0.1 to 5.0
16.name= ~via_points_ordered
16.default= False
16.type= bool
16.desc=If true, the planner adheres to the order of via-points in the storage container 
17.name= ~max_vel_x
17.default= 0.4
17.type= double
17.desc=Maximum velocity in the x direction of the robot. May be overruled by the max_vel_trans parameter Range: 0.01 to 100.0
18.name= ~max_vel_x_backwards
18.default= 0.2
18.type= double
18.desc=Maximum translational velocity of the robot for driving backwards Range: 0.01 to 100.0
19.name= ~max_vel_theta
19.default= 0.3
19.type= double
19.desc=Maximum angular velocity of the robot Range: 0.01 to 100.0
20.name= ~acc_lim_x
20.default= 0.5
20.type= double
20.desc=Maximum translational acceleration of the robot Range: 0.01 to 100.0
21.name= ~acc_lim_theta
21.default= 0.5
21.type= double
21.desc=Maximum angular acceleration of the robot Range: 0.01 to 100.0
22.name= ~is_footprint_dynamic
22.default= False
22.type= bool
22.desc=If true, updated the footprint before checking trajectory feasibility 
23.name= ~use_proportional_saturation
23.default= False
23.type= bool
23.desc=If true, reduce all twists components (linear x and y, and angular z) proportionally if any exceed its corresponding bounds, instead of saturating each one individually 
24.name= ~transform_tolerance
24.default= 0.5
24.type= double
24.desc=Tolerance when querying the TF Tree for a transformation (seconds) Range: 0.001 to 20.0
25.name= ~min_turning_radius
25.default= 0.0
25.type= double
25.desc=Minimum turning radius of a carlike robot (diff-drive robot: zero) Range: 0.0 to 50.0
26.name= ~wheelbase
26.default= 1.0
26.type= double
26.desc=The distance between the drive shaft and steering axle (only required for a carlike robot with 'cmd_angle_instead_rotvel' enabled); The value might be negative for back-wheeled robots! Range: -10.0 to 10.0
27.name= ~cmd_angle_instead_rotvel
27.default= False
27.type= bool
27.desc=Substitute the rotational velocity in the commanded velocity message by the corresponding steering angle (check 'axles_distance') 
28.name= ~max_vel_y
28.default= 0.0
28.type= double
28.desc=Maximum strafing velocity of the robot (should be zero for non-holonomic robots!). May be overruled by the max_vel_trans parameter Range: 0.0 to 100.0
29.name= ~max_vel_trans
29.default= 0.0
29.type= double
29.desc=Maximum linear velocity of the robot. Will limit max_vel_x and max_vel_y when their linear combination exceeds its value. When set to default 0.0, it will be set equal to max_vel_x. Range: 0.0 to 100.0
30.name= ~acc_lim_y
30.default= 0.5
30.type= double
30.desc=Maximum strafing acceleration of the robot Range: 0.01 to 100.0
31.name= ~xy_goal_tolerance
31.default= 0.2
31.type= double
31.desc=Allowed final euclidean distance to the goal position Range: 0.001 to 10.0
32.name= ~yaw_goal_tolerance
32.default= 0.1
32.type= double
32.desc=Allowed final orientation error to the goal orientation Range: 0.001 to 3.2
33.name= ~free_goal_vel
33.default= False
33.type= bool
33.desc=Allow the robot's velocity to be nonzero for planning purposes (the robot can arrive at the goal with max speed) 
34.name= ~trans_stopped_vel
34.default= 0.1
34.type= double
34.desc=Below what maximum velocity we consider the robot to be stopped in translation Range: 0.0 to std::numeric_limits<double>::infinity()
35.name= ~theta_stopped_vel
35.default= 0.1
35.type= double
35.desc=Below what maximum rotation velocity we consider the robot to be stopped in rotation Range: 0.0 to std::numeric_limits<double>::infinity()
36.name= ~min_obstacle_dist
36.default= 0.5
36.type= double
36.desc=Minimum desired separation from obstacles Range: 0.0 to 10.0
37.name= ~inflation_dist
37.default= 0.6
37.type= double
37.desc=Buffer zone around obstacles with non-zero penalty costs (should be larger than min_obstacle_dist in order to take effect) Range: 0.0 to 15.0
38.name= ~dynamic_obstacle_inflation_dist
38.default= 0.6
38.type= double
38.desc=Buffer zone around predicted locations of dynamic obstacles with non-zero penalty costs (should be larger than min_obstacle_dist in order to take effect) Range: 0.0 to 15.0
39.name= ~include_dynamic_obstacles
39.default= False
39.type= bool
39.desc=Specify whether the movement of dynamic obstacles should be predicted by a constant velocity model (this also changes the homotopy class search). If false, all obstacles are considered to be static. 
40.name= ~include_costmap_obstacles
40.default= True
40.type= bool
40.desc=Specify whether the obstacles in the costmap should be taken into account directly (this is necessary if no seperate clustering and detection is implemented) 
41.name= ~legacy_obstacle_association
41.default= False
41.type= bool
41.desc=If true, the old association strategy is used (for each obstacle, find the nearest TEB pose), otherwise the new one (for each teb pose, find only 'relevant' obstacles). 
42.name= ~obstacle_association_force_inclusion_factor
42.default= 1.5
42.type= double
42.desc=The non-legacy obstacle association technique tries to connect only relevant obstacles with the discretized trajectory during optimization, all obstacles within a specifed distance are forced to be included (as a multiple of min_obstacle_dist), e.g. choose 2.0 in order to consider obstacles within a radius of 2.0*min_obstacle_dist. Range: 0.0 to 100.0
43.name= ~obstacle_association_cutoff_factor
43.default= 5.0
43.type= double
43.desc=See obstacle_association_force_inclusion_factor, but beyond a multiple of [value]*min_obstacle_dist all obstacles are ignored during optimization. obstacle_association_force_inclusion_factor is processed first. Range: 1.0 to 100.0
44.name= ~costmap_obstacles_behind_robot_dist
44.default= 1.5
44.type= double
44.desc=Limit the occupied local costmap obstacles taken into account for planning behind the robot (specify distance in meters) Range: 0.0 to 20.0
45.name= ~obstacle_poses_affected
45.default= 30
45.type= int
45.desc=The obstacle position is attached to the closest pose on the trajectory to reduce computational effort, but take a number of neighbors into account as well Range: 0 to 200
46.name= ~obstacle_proximity_ratio_max_vel
46.default= 1.0
46.type= double
46.desc=Ratio of the maximum velocities used as an upper bound when reducing the speed due to the proximity to static obstacles Range: 0.0 to 1.0
47.name= ~obstacle_proximity_lower_bound
47.default= 0.0
47.type= double
47.desc=Distance to a static obstacle for which the velocity should be lower Range: 0.0 to 10.0
48.name= ~obstacle_proximity_upper_bound
48.default= 0.5
48.type= double
48.desc=Distance to a static obstacle for which the velocity should be higher Range: 0.0 to 10.0
49.name= ~no_inner_iterations
49.default= 5
49.type= int
49.desc=Number of solver iterations called in each outerloop iteration Range: 1 to 100
50.name= ~no_outer_iterations
50.default= 4
50.type= int
50.desc=Each outerloop iteration automatically resizes the trajectory and invokes the internal optimizer with no_inner_iterations Range: 1 to 100
51.name= ~optimization_activate
51.default= True
51.type= bool
51.desc=Activate the optimization 
52.name= ~optimization_verbose
52.default= False
52.type= bool
52.desc=Print verbose information 
53.name= ~penalty_epsilon
53.default= 0.05
53.type= double
53.desc=Add a small safty margin to penalty functions for hard-constraint approximations Range: 0.0 to 1.0
54.name= ~weight_max_vel_x
54.default= 2.0
54.type= double
54.desc=Optimization weight for satisfying the maximum allowed translational velocity Range: 0.0 to 1000.0
55.name= ~weight_max_vel_y
55.default= 2.0
55.type= double
55.desc=Optimization weight for satisfying the maximum allowed strafing velocity (in use only for holonomic robots) Range: 0.0 to 1000.0
56.name= ~weight_max_vel_theta
56.default= 1.0
56.type= double
56.desc=Optimization weight for satisfying the maximum allowed angular velocity Range: 0.0 to 1000.0
57.name= ~weight_acc_lim_x
57.default= 1.0
57.type= double
57.desc=Optimization weight for satisfying the maximum allowed translational acceleration Range: 0.0 to 1000.0
58.name= ~weight_acc_lim_y
58.default= 1.0
58.type= double
58.desc=Optimization weight for satisfying the maximum allowed strafing acceleration (in use only for holonomic robots) Range: 0.0 to 1000.0
59.name= ~weight_acc_lim_theta
59.default= 1.0
59.type= double
59.desc=Optimization weight for satisfying the maximum allowed angular acceleration Range: 0.0 to 1000.0
60.name= ~weight_kinematics_nh
60.default= 1000.0
60.type= double
60.desc=Optimization weight for satisfying the non-holonomic kinematics Range: 0.0 to 10000.0
61.name= ~weight_kinematics_forward_drive
61.default= 1.0
61.type= double
61.desc=Optimization weight for forcing the robot to choose only forward directions (positive transl. velocities, only diffdrive robot) Range: 0.0 to 10000.0
62.name= ~weight_kinematics_turning_radius
62.default= 1.0
62.type= double
62.desc=Optimization weight for enforcing a minimum turning radius (carlike robots) Range: 0.0 to 1000.0
63.name= ~weight_optimaltime
63.default= 1.0
63.type= double
63.desc=Optimization weight for contracting the trajectory w.r.t. transition time Range: 0.0 to 1000.0
64.name= ~weight_shortest_path
64.default= 0.0
64.type= double
64.desc=Optimization weight for contracting the trajectory w.r.t. path length Range: 0.0 to 100.0
65.name= ~weight_obstacle
65.default= 50.0
65.type= double
65.desc=Optimization weight for satisfying a minimum seperation from obstacles Range: 0.0 to 1000.0
66.name= ~weight_inflation
66.default= 0.1
66.type= double
66.desc=Optimization weight for the inflation penalty (should be small) Range: 0.0 to 10.0
67.name= ~weight_dynamic_obstacle
67.default= 50.0
67.type= double
67.desc=Optimization weight for satisfying a minimum seperation from dynamic obstacles Range: 0.0 to 1000.0
68.name= ~weight_dynamic_obstacle_inflation
68.default= 0.1
68.type= double
68.desc=Optimization weight for the inflation penalty of dynamic obstacles (should be small) Range: 0.0 to 10.0
69.name= ~weight_velocity_obstacle_ratio
69.default= 0.0
69.type= double
69.desc=Optimization weight for satisfying a maximum allowed velocity with respect to the distance to a static obstacle Range: 0.0 to 1000.0
70.name= ~weight_viapoint
70.default= 1.0
70.type= double
70.desc=Optimization weight for minimizing the distance to via-points Range: 0.0 to 1000.0
71.name= ~weight_adapt_factor
71.default= 2.0
71.type= double
71.desc=Some special weights (currently 'weight_obstacle') are repeatedly scaled by this factor in each outer TEB iteration (weight_new: weight_old * factor); Increasing weights iteratively instead of setting a huge value a-priori leads to better numerical conditions of the underlying optimization problem. Range: 1.0 to 100.0
72.name= ~obstacle_cost_exponent
72.default= 1.0
72.type= double
72.desc=Exponent for nonlinear obstacle cost (cost = linear_cost * obstacle_cost_exponent). Set to 1 to disable nonlinear cost (default) Range: 0.01 to 100.0
73.name= ~enable_multithreading
73.default= True
73.type= bool
73.desc=Activate multiple threading for planning multiple trajectories in parallel 
74.name= ~max_number_classes
74.default= 5
74.type= int
74.desc=Specify the maximum number of allowed alternative homotopy classes (limits computational effort) Range: 1 to 100
75.name= ~max_number_plans_in_current_class
75.default= 1
75.type= int
75.desc=Max number of trajectories to try that are in the same homotopy class as the current best trajectory (setting this to 2 or more helps avoid local minima). Must be <= max_number_classes Range: 1 to 10
76.name= ~selection_cost_hysteresis
76.default= 1.0
76.type= double
76.desc=Specify how much trajectory cost must a new candidate have w.r.t. a previously selected trajectory in order to be selected (selection if new_cost < old_cost*factor) Range: 0.0 to 2.0
77.name= ~selection_prefer_initial_plan
77.default= 0.95
77.type= double
77.desc=Specify a cost reduction in the interval (0,1) for the trajectory in the equivalence class of the initial plan.) Range: 0.0 to 1.0
78.name= ~selection_obst_cost_scale
78.default= 2.0
78.type= double
78.desc=Extra scaling of obstacle cost terms just for selecting the 'best' candidate (new_obst_cost: obst_cost*factor) Range: 0.0 to 1000.0
79.name= ~selection_viapoint_cost_scale
79.default= 1.0
79.type= double
79.desc=Extra scaling of via-point cost terms just for selecting the 'best' candidate. (new_viapt_cost: viapt_cost*factor) Range: 0.0 to 100.0
80.name= ~selection_alternative_time_cost
80.default= False
80.type= bool
80.desc=If true, time cost is replaced by the total transition time. 
81.name= ~selection_dropping_probability
81.default= 0.0
81.type= double
81.desc=At each planning cycle, TEBs other than the current 'best' one will be randomly dropped with this probability. Prevents becoming 'fixated' on sub-optimal alternative homotopies. Range: 0.0 to 1.0
82.name= ~switching_blocking_period
82.default= 0.0
82.type= double
82.desc=Specify a time duration in seconds that needs to be expired before a switch to new equivalence class is allowed Range: 0.0 to 60.0
83.name= ~roadmap_graph_no_samples
83.default= 15
83.type= int
83.desc=Specify the number of samples generated for creating the roadmap graph, if simple_exploration is turend off Range: 1 to 100
84.name= ~roadmap_graph_area_width
84.default= 5.0
84.type= double
84.desc=Specify the width of the area in which sampled will be generated between start and goal [m] (the height equals the start-goal distance) Range: 0.1 to 20.0
85.name= ~roadmap_graph_area_length_scale
85.default= 1.0
85.type= double
85.desc=The length of the rectangular region is determined by the distance between start and goal. This parameter further scales the distance such that the geometric center remains equal!) Range: 0.5 to 2.0
86.name= ~h_signature_prescaler
86.default= 1.0
86.type= double
86.desc=Scale number of obstacle value in order to allow huge number of obstacles. Do not choose it extremly low, otherwise obstacles cannot be distinguished from each other (0.2<H<=1) Range: 0.2 to 1.0
87.name= ~h_signature_threshold
87.default= 0.1
87.type= double
87.desc=Two h-signuteres are assumed to be equal, if both the difference of real parts and complex parts are below the specified threshold Range: 0.0 to 1.0
88.name= ~obstacle_heading_threshold
88.default= 0.45
88.type= double
88.desc=Specify the value of the normalized scalar product between obstacle heading and goal heading in order to take them (obstacles) into account for exploration) Range: 0.0 to 1.0
89.name= ~viapoints_all_candidates
89.default= True
89.type= bool
89.desc=If true, all trajectories of different topologies are attached to the set of via-points, otherwise only the trajectory sharing the same one as the initial/global plan is attached (no effect in test_optim_node). 
90.name= ~visualize_hc_graph
90.default= False
90.type= bool
90.desc=Visualize the graph that is created for exploring new homotopy classes 
91.name= ~shrink_horizon_backup
91.default= True
91.type= bool
91.desc=Allows the planner to shrink the horizon temporary (50%) in case of automatically detected issues. 
92.name= ~oscillation_recovery
92.default= True
92.type= bool
92.desc=Try to detect and resolve oscillations between multiple solutions in the same equivalence class (robot frequently switches between left/right/forward/backwards). 
93.name= ~divergence_detection_enable
93.default= False
93.type= bool
93.desc=True to enable divergence detection. 
94.name= ~divergence_detection_max_chi_squared
94.default= 10.0
94.type= double
94.desc=Maximum acceptable Mahalanobis distance above which it is assumed that the optimization diverged. Range: 0.0 to 100.0
}
}
# End of autogenerated section. You may edit below.
